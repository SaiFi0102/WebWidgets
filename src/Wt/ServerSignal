#ifndef SERVER_SIGNAL_H_
#define SERVER_SIGNAL_H_

#include <Wt/WObject>
#include <boost/thread.hpp>

#include <boost/bind.hpp>
#ifndef WT_NO_BOOST_INTRUSIVE
#include <boost/intrusive/list.hpp>
#endif

namespace Wt
{
	template <typename A1 = NoClass, typename A2 = NoClass,
	  typename A3 = NoClass, typename A4 = NoClass,
	  typename A5 = NoClass, typename A6 = NoClass>
	class ServerSignal
	{
	public:
		class Connection
		{
			public:
				~Connection();

				void block() const;
				void unblock() const;
				void blocked() const;

			private:
				Connection(ServerSignal *Signal) {};
				ServerSignal *_signal;
				bool _blocked;
		};

		ServerSignal(WServer *sender = 0);
		~ServerSignal();

		template <class F> Connection *connect(const F& function);
		//Wt::Signals::connection connect(const boost::bound& f);
		virtual bool isConnected() const;

		void emit(A1 a1 = NoClass::none, A2 a2 = NoClass::none,
			A3 a3 = NoClass::none, A4 a4 = NoClass::none,
			A5 a5 = NoClass::none, A6 a6 = NoClass::none) const;
		void operator()(A1 a1 = NoClass::none, A2 a2 = NoClass::none,
			A3 a3 = NoClass::none, A4 a4 = NoClass::none,
			A5 a5 = NoClass::none, A6 a6 = NoClass::none) const;

	private:
		typedef std::set<Connection *> ConnectionsSet;

		Signal(const Signal<A1, A2, A3, A4, A5, A6> &);
		void disconnect(Connection *conn);
		void block(Connection *conn, bool should_block) const;

		WServer *_sender;
		ConnectionsSet _connections;
		mutable boost::shared_mutex mutex;
	};

	#ifndef WT_CNOR

	/*
	 * Normal signal -- specialization for void
	 */
	template<>
	class WT_API Signal<void> : public Signal<>
	{ 
	public:
	  Signal<void, NoClass, NoClass, NoClass, NoClass, NoClass>
		(WObject *sender = 0);
	};

	#else // WT_CNOR

	class WT_API Signal0 : public Signal<NoClass>
	{
	public:
	  Signal0(WObject *sender = 0);

	  void emit() const;

	  template<class T, class V>
		Wt::Signals::connection connect(T *target, void (V::*method)());
	  Wt::Signals::connection connect(const boost::bound& f);
	};

	#endif // WT_CNOR

	/*! \brief Abstract base class of an event signal.
	 *
	 * An event signal is directly associated with a user-interface generated
	 * event.
	 *
	 * \ingroup signalslot
	 */
	class WT_API EventSignalBase : public SignalBase
	#if !(defined(WT_TARGET_JAVA) || defined(WT_NO_BOOST_INTRUSIVE))
					 ,public boost::intrusive::list_base_hook<>
	#endif
	{
	public:
	  virtual ~EventSignalBase();

	  /*! \brief Returns the event name.
	   *
	   * The event name is implementation-defined.
	   */
	  const char *name() const { return name_; }

	  bool needsUpdate(bool all) const;
	  void updateOk();
	  virtual bool isConnected() const;

	  virtual const std::string encodeCmd() const;
	  const std::string javaScript() const;
	  bool isExposedSignal() const;
	  bool canAutoLearn() const;
	  void setNotExposed();
	  void disconnect(Wt::Signals::connection& conn);

	  /*! \brief Prevents the default browser action.
	   *
	   * Use this method to prevent the default browser action associated
	   * with this event.
	   *
	   * \sa setPreventPropagation()
	   */
	  void preventDefaultAction(bool prevent = true);

	  /*! \brief Returns whether the default browser action is prevented.
	   *
	   * \sa preventDefaultAction()
	   */
	  bool defaultActionPrevented() const;

	  /*! \brief Prevents event propagation.
	   *
	   * Use this method to prevent that the event propagates further to
	   * its ancestors.
	   *
	   * \sa preventDefaultAction()
	   */
	  void preventPropagation(bool prevent = true);

	  /*! \brief Returns whether event propagation is prevented.
	   *
	   * \sa preventPropagation()
	   */
	  bool propagationPrevented() const;

	  const std::string createUserEventCall(const std::string& jsObject,
						const std::string& jsEvent,
						const std::string& eventName,
						const std::string& arg1,
						const std::string& arg2,
						const std::string& arg3,
						const std::string& arg4,
						const std::string& arg5,
						const std::string& arg6) const;

	  Wt::Signals::connection connectStateless(WObject::Method method, 
							  WObject *target,
							  WStatelessSlot *slot);
	  using SignalBase::connect;
	  void connect(JSlot& slot);
	  void connect(const std::string& function);

	  void senderRepaint();

	protected:
	  struct StatelessConnection {
		Wt::Signals::connection connection;
		WObject                   *target;
		WStatelessSlot            *slot;

		bool ok() const;

		StatelessConnection(const Wt::Signals::connection& c,
				WObject *target, WStatelessSlot *slot);
	  };

	  static const int BIT_NEED_UPDATE = 0;
	  static const int BIT_SERVER_EVENT = 1;
	  static const int BIT_EXPOSED = 2;
	  static const int BIT_CAN_AUTOLEARN = 3;
	  static const int BIT_PREVENT_DEFAULT = 4;
	  static const int BIT_PREVENT_PROPAGATION = 5;
	  static const int BIT_SIGNAL_SERVER_ANYWAY = 6;

	  static int nextId_;

	  const char                       *name_;
	  const int                         id_;
	  std::vector<StatelessConnection>  connections_;
	  std::bitset<7>                    flags_;

	  /*
	   * Dummy signal used for knowing if stateless connections are still
	   * connected.
	   */
	#ifndef WT_CNOR
	  Wt::Signals::signal<void()>              dummy_;
	#else
	  Wt::Signals::signal0<void>              dummy_;
	#endif

	  EventSignalBase(const char *name, WObject *sender, bool autoLearn);

	  void prepareDestruct();
	  void exposeSignal();
	  void processLearnedStateless() const;
	  void processNonLearnedStateless() const;

	  static void *alloc();
	  static void free(void *s);

	private:
	  /*
	   * Our own list of connections to process them in a custom way.
	   */

	  void removeSlot(WStatelessSlot *slot);

	  void processPreLearnStateless(SlotLearnerInterface *learner);
	  void processAutoLearnStateless(SlotLearnerInterface *learner);
	  virtual void processDynamic(const JavaScriptEvent& e) = 0;

	  friend class WStatelessSlot;
	  friend class WebRenderer;
	  friend class WebSession;
	};

	/*! \class EventSignal Wt/WSignal Wt/WSignal
	 *  \brief A signal that conveys user-interface events.
	 *
	 * An %EventSignal is a special %Signal that may be triggered by user
	 * interface events such as a mouse click, key press, or focus change.
	 * They are made available through the library in widgets like
	 * WInteractWidget, and should not be instantiated directly.
	 *
	 * In addition to the behaviour of %Signal, they are capable of both
	 * executing client-side and server-side slot code. They may learn
	 * JavaScript from C++ code, through stateless slot learning, when
	 * connected to a slot that has a stateless implementation, using
	 * WObject::implementStateless(). Or they may be connected to a JSlot
	 * which provides manual JavaScript code.
	 *
	 * The typically relay UI event details, using event details objects
	 * like WKeyEvent or WMouseEvent.
	 *
	 * \sa Signal, JSignal
	 *
	 * \ingroup signalslot
	 */
	template<typename E = NoClass>
	class EventSignal : public EventSignalBase
	{
	public:
	#ifndef WT_TARGET_JAVA
	#ifndef __clang__
	  // see bug: http://llvm.org/bugs/show_bug.cgi?id=6920
	  static void *operator new(std::size_t size);
	  static void operator delete(void *deletable, std::size_t size);
	#endif // __clang__

	  EventSignal(const char *name, WObject *sender);
	#else
	  EventSignal(const char *name, WObject *sender, const E& e);
	#endif // WT_TARGET_JAVA

	  /*! \brief Returns whether the signal is connected.
	   */
	  virtual bool isConnected() const;

	  /*! \brief Connects to a function.
	   *
	   * This variant of the overloaded connect() method supports a
	   * template function object (which supports operator ()).
	   *
	   * When the receiver function is an object method, the signal will
	   * automatically be disconnected when the object is deleted, as long as the
	   * object inherits from WObject (or Wt::Signals::trackable).
	   *
	   * The function may leave 1 parameters unbound (e.g. using
	   * boost::bind placeholders _1) that may be bound to the event
	   * detail object passed by the signal.
	   */
	#ifndef WT_CNOR
	  template <class F> Wt::Signals::connection connect(const F& function);
	#else
	  Wt::Signals::connection connect(const boost::bound& function);
	#endif

	  /*! \brief Connects a slot that takes no arguments.
	   *
	   * If a stateless implementation is specified for the slot, then
	   * the visual behaviour will be learned in terms of JavaScript, and
	   * will be cached on the client side for instant feed-back, in
	   * addition running the slot on the server.
	   *
	   * The slot is as a \p method of an object \p target of class \p T,
	   * which equals class \p V, or is a base class of class \p V. In
	   * addition, to check for stateless implementations, class \p T must
	   * be also be a descendant of WObject. Thus, the following statement
	   * must return a non-null pointer:
	   *
	   * \code
	   * WObject *o = dynamic_cast<WObject *>(dynamic_cast<V *>(target));
	   * \endcode
	   */
	  template<class T, class V>
		Wt::Signals::connection connect(T *target, void (V::*method)());

	  /*! \brief Connects a slot that takes one argument.
	   *
	   * This is only possible for signals that take at least one argument.
	   */
	  template<class T, class V>
		Wt::Signals::connection connect(T *target, void (V::*method)(E));

	  /*! \brief Connects a slot that takes a 'const argument&'.
	   *
	   * This is only possible for signals that take at least one argument.
	   */
	  template<class T, class V>
		Wt::Signals::connection connect(T *target, void (V::*method)(const E&));

	  /*! \brief Connects a JavaScript function.
	   *
	   * This will provide a client-side connection between the event and
	   * a JavaScript function. The argument must be a JavaScript function
	   * which optionally accepts two arguments (object and the event):
	   *
	   * \code
	   * function(object, event) {
	   *   ...
	   * }
	   * \endcode
	   *
	   * Unlike a JSlot, there is no automatic connection management: the
	   * connection cannot be removed. If you need automatic connection
	   * management, you should use connect(JSlot&) instead.
	   */
	  void connect(const std::string& function);
	  void connect(const char * function);

	  /*! \brief Connects a slot that is specified as JavaScript only.
	   *
	   * This will provide a client-side connection between the event and
	   * some JavaScript code as implemented by the slot. Unlike other
	   * connects, this does not cause the event to propagated to the
	   * application, and thus the state changes caused by the JavaScript
	   * slot are not tracked client-side.
	   *
	   * The connection is tracked, taking into account the life-time of
	   * the JSlot object, and can be updated by modifying the \p slot. If
	   * you do not need connection management (e.g. because the slot has
	   * the same life-time as the signal), then you can use connect(const
	   * std::string&) instead.
	   */
	  void connect(JSlot& slot);

	  /*! \brief Emits the signal.
	   *
	   * This will cause all connected slots to be triggered, with the given
	   * argument.
	   */
	  void emit(E e = NoClass::none) const;

	  /*! \brief Emits the signal.
	   *
	   * This is equivalent to emit().
	   *
	   * \sa emit()
	   */
	  void operator()(E e) const;

	  virtual Wt::Signals::connection connect(WObject *target,
							 WObject::Method method);

	private:
	#ifndef WT_CNOR
	  typedef Wt::Signals::signal<void(E)> BoostSignalType;
	#else
	  typedef Wt::Signals::signal1<void, E> BoostSignalType;
	#endif
	  BoostSignalType dynamic_;

	  void processDynamic(const JavaScriptEvent& e);
	};

	#ifdef WT_CNOR

	class WT_API EventSignal0 : public EventSignalBase
	{
	public:
	  EventSignal0(const char *name, WObject *sender);
	  ~EventSignal0();

	  virtual bool isConnected() const;

	  Wt::Signals::connection connect(const boost::bound& f);
	  void connect(const std::string& function);
	  void connect(JSlot& slot);
	  template<class T, class V>
		Wt::Signals::connection connect(T *target, void (V::*method)());

	  void emit() const;
	  void operator()() const;
	};

	#endif // WT_CNOR

	#ifndef WT_CNOR

	template <class T, class V>
	Wt::Signals::connection SignalBase::connect(T *target,
							   void (V::*method)())
	{
	  WObject *o = dynamic_cast<WObject *>(dynamic_cast<V *>(target));
	  assert(o);
	  return connect(o, static_cast<WObject::Method>(method));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	Signal<A1, A2, A3, A4, A5, A6>::Signal(WObject *sender)
	  : SignalBase(sender),
		impl_(0)
	{
	#ifdef A6_MUST_BE_NOCLASS
	  A6 YourMsvsOnlySupports5BindArguments = NoClass::none;
	#endif
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	Signal<A1, A2, A3, A4, A5, A6>::~Signal()
	{  
	  delete impl_;
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class F>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(const F& function)
	{
	  if (!impl_)
		impl_ = new BoostSignalType;
	  return impl_->connect(function, Wt::Signals::at_front);
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(A1, A2, A3, A4, A5, A6))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1, ::_2, ::_3, ::_4, ::_5, ::_6));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(A1, A2, A3, A4, A5))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1, ::_2, ::_3, ::_4, ::_5));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(A1, A2, A3, A4))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1, ::_2, ::_3, ::_4));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(const A1&, const A2&, const A3&))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1, ::_2, ::_3));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(const A1&, const A2&, A3))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1, ::_2, ::_3));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(const A1&, A2, A3))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1, ::_2, ::_3));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(A1, A2, A3))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1, ::_2, ::_3));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(const A1&, const A2&))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1, ::_2));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(const A1&, A2))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1, ::_2));
	}


	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(A1, const A2&))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1, ::_2));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(A1, A2))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1, ::_2));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(const A1&))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, _1));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)(A1))
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target, ::_1));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	template <class T, class V>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(T *target, void (V::*method)())
	{
	  assert(dynamic_cast<V *>(target));
	  return connect(boost::bind(method, target));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	Wt::Signals::connection Signal<A1, A2, A3, A4, A5, A6>
	::connect(WObject *target, WObject::Method method)
	{
	  return connect(boost::bind(method, target));
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	void Signal<A1, A2, A3, A4, A5, A6>::emit(A1 a1, A2 a2, A3 a3,
						  A4 a4, A5 a5, A6 a6) const
	{
	  if (impl_ && !isBlocked()) {
		pushSender(sender());
	#ifndef A6_MUST_BE_NOCLASS
		(*impl_)(a1, a2, a3, a4, a5, a6);
	#else
		(*impl_)(a1, a2, a3, a4, a5);
	#endif
		popSender();
	  }
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	void Signal<A1, A2, A3, A4, A5, A6>::operator()(A1 a1, A2 a2, A3 a3,
							A4 a4, A5 a5, A6 a6) const
	{
	  emit(a1, a2, a3, a4, a5, a6);
	}

	template <typename A1, typename A2, typename A3,
		  typename A4, typename A5, typename A6>
	bool Signal<A1, A2, A3, A4, A5, A6>::isConnected() const
	{
	  return impl_ ? impl_->num_slots() > 0 : false;
	}

	#ifndef __clang__
	template <typename E>
	void *EventSignal<E>::operator new(std::size_t) {
	  return EventSignalBase::alloc();
	}

	template <typename E>
	void EventSignal<E>::operator delete(void *deletable, std::size_t) {
	  EventSignalBase::free(deletable);
	}
	#endif // __clang__

	template <typename E>
	EventSignal<E>::EventSignal(const char *name, WObject *sender)
	  : EventSignalBase(name, sender, true)
	{ }

	template <typename E>
	bool EventSignal<E>::isConnected() const
	{
	  if (EventSignalBase::isConnected())
		return true;

	  return dynamic_.num_slots() > 0;
	}

	template <typename E>
	template <class F>
	Wt::Signals::connection EventSignal<E>::connect(const F& function)
	{
	  exposeSignal();
	  return dynamic_.connect(function, Wt::Signals::at_front);
	}

	template <typename E>
	template <class T, class V>
	Wt::Signals::connection EventSignal<E>::connect(T *target,
							   void (V::*method)())
	{
	  exposeSignal();
	  WObject *o = dynamic_cast<WObject *>(dynamic_cast<V *>(target));
	  assert(o);

	  WStatelessSlot *s = o->isStateless(static_cast<WObject::Method>(method));

	  if (s)
		return EventSignalBase::connectStateless
		  (static_cast<WObject::Method>(method), o, s);
	  else
		return dynamic_.connect(boost::bind(method, target),
					Wt::Signals::at_front);
	}

	template <typename E>
	template <class T, class V>
	Wt::Signals::connection EventSignal<E>::connect(T *target,
							   void (V::*method)(E))
	{
	  exposeSignal();
	  assert(dynamic_cast<V *>(target));

	  return dynamic_.connect(boost::bind(method, target, ::_1),
				  Wt::Signals::at_front);
	}

	template <typename E>
	template <class T, class V>
	Wt::Signals::connection EventSignal<E>::connect(T *target,
							   void (V::*method)(const E&))
	{
	  exposeSignal();
	  assert(dynamic_cast<V *>(target));

	  return dynamic_.connect(boost::bind(method, target, ::_1),
				  Wt::Signals::at_front);
	}

	template <typename E>
	void EventSignal<E>::connect(const char *function)
	{
	  EventSignalBase::connect(function);
	}

	template <typename E>
	void EventSignal<E>::connect(const std::string& function)
	{
	  EventSignalBase::connect(function);
	}

	template <typename E>
	void EventSignal<E>::connect(JSlot& slot)
	{
	  EventSignalBase::connect(slot);
	}

	template <typename E>
	Wt::Signals::connection
	EventSignal<E>::connect(WObject *target, WObject::Method method)
	{
	  exposeSignal();
	  WStatelessSlot *s = target->isStateless(method);
	  if (s)
		return EventSignalBase::connectStateless(method, target, s);
	  else
		return dynamic_.connect(boost::bind(method, target),
					Wt::Signals::at_front);
	}

	template <typename E>
	void EventSignal<E>::emit(E e) const
	{
	  if (isBlocked())
		return;

	  pushSender(sender());

	  processLearnedStateless();
	  processNonLearnedStateless();

	  dynamic_(e);

	  popSender();
	}

	template <typename E>
	void EventSignal<E>::operator()(E e) const
	{
	  emit(e);
	}

	template <typename E>
	void EventSignal<E>::processDynamic(const JavaScriptEvent& jse)
	{
	  processNonLearnedStateless();

	  E event(jse);

	  if (dynamic_.num_slots()) {
		pushSender(sender());
		dynamic_(event);
		popSender();
	  }
	}

	#endif // WT_CNOR

}

#endif // WSIGNAL_H_
